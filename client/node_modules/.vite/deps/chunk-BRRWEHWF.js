import {
  require_assert,
  require_utils
} from "./chunk-IZV5VOWE.js";
import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/ethereum-cryptography/utils.js
var require_utils2 = __commonJS({
  "node_modules/ethereum-cryptography/utils.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
    var _assert_1 = __importDefault(require_assert());
    var utils_1 = require_utils();
    var assertBool = _assert_1.default.bool;
    exports.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports.assertBytes = assertBytes;
    var utils_2 = require_utils();
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    exports.bytesToUtf8 = bytesToUtf8;
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    exports.hexToBytes = hexToBytes;
    function equalsBytes(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports.equalsBytes = equalsBytes;
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports.wrapHash = wrapHash;
    exports.crypto = (() => {
      const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

export {
  require_utils2 as require_utils
};
//# sourceMappingURL=chunk-BRRWEHWF.js.map
